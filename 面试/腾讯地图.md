1. c++虚函数表存在哪里？如何查找到的？模板类与虚函数的区别与应用场景
    每个实例对象的开头存放了指向虚函数表的指针，通过指针找到对应类的虚函数表，然后在虚函数表中查找相应的调用函数的地址就可。
    模板类和虚函数都可以用于多态的实现，他们的主要区别：
    - 模板类是静态的，编译期的多态，是面向类型的，而虚函数则是动态的，是运行时的多态，面向的是行为
    - 虚函数、好处就是无论多少函数都是多分配一个指针的空间而已(牺牲速度换空间)
    - 模板、快、但有多少实际应用生成多少代码（牺牲空间换速度）
    应用场景上：
    - 同一项目内部，尽可能使用模板，带来的是性能和空间上的改善，跨项目则不要传递模板，即使看起来是同一个模板，在不同项目中的内存布局也可能是不同的。因此某个接口需要公开，或者允许外部项目实现，模板无能为力，只能使用虚函数。
2. select,poll,epoll
3. 数据库事务隔离级别
    数据库中多用户并发可能发生的问题如下：丢失修改，脏读，不可重复读，幻读
    - 丢失修改：事务A修改数据的同时事务B也修改数据，随后事务B提交的修改覆盖了已提交的事务A
    - 脏读：事务A修改数据后尚未提交时事务B就来读数据。
    - 不可重复读：一个事务执行过程中多次读到不同数据，这些数据都是已经提交完成的。
    - 幻读：一个事务修改一批数据时，另一事务插入了新的同属该批的数据，造成该数据未修改。
    针对这些问题，提出了隔离级别
    - 读取未提交内容：避免了事务同时进行修改，也就避免了丢失修改
    - 读取提交：避免了脏读
    - 可重复读：避免了不可重复读
    - 序列化：避免幻读

4. 操作系统分页机制
    - 虚拟内存的提出
    1. 虚拟内存将主存看作是存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间传送数据。
    2. 给每个进程提供了一致的地址空间，简化了内存管理。
    3. 保证了各个进程之间的独立性。

    - 页表
    页表是虚拟地址到物理地址映射的数据结构，他的数量与虚拟内存的页数量一致，因此虚拟地址的前几位表示在页表中的偏移，然
    后就可以根据页表该位置存储的物理页号来构造相应的物理地址。


5. 希尔排序
6. n!的末尾零个数：
    n!=(5*K)*(5*(K-1))*...*5*A,A为不包含5的因子乘积，n=5*K+r(0<=r<=4),假设f(n!)为n!末尾为0的个数，g(n!)为n!中5因子的个数，那么
    f(n!)=g(n!)=g(5^K*K!*A)=K+g(K!)=K+f(K!),其中K=n/5(下取整)
7. unique_ptr的赋值问题:unique_ptr拷贝构造和赋值构造被删除，可以使用移动构造和移动赋值来进行操作。
