1. static
    - static延长了变量的生命周期，但又不会破坏变量的访问范围，初始化的静态变量存储在Data段，未初始化的静态变量存储在BSS段，它仅仅初始化一次
    - static修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。
    - static修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。
    - static修饰类成员属于类变量，可以通过类名.变量名直接引用，是类之间共享的，修饰函数也同上道理。
    - 静态成员函数不能引用非静态成员，只能调用初始化好的静态成员，反之可以，这是由于静态成员函数初始化比较早的原因。

2. extern
    - extern与C一起连用，代表告诉编译器用C的方式去编译相应的函数
    - extern不与C一起连用，就是声明函数或者全局变量的作用。

3. constexpr
常量表达式是指不会改变并且在编译过程就可以得到计算结果的表达式。声明为constexpr的变量一定是一个常量，并且必须用常量表达式初始化。
constexpr修饰函数指代能用于常量表达式的函数，1.函数的返回类型以及所有形参的类型都是字面值类型，2.函数体有且只有一条return语句。
内联函数和constexpr函数可以多次定义，因此通常定义在头文件中。

4. 引用与指针
指针和引用的修饰符只是修饰离他最近的变量，例如
int* p1,p2;//p1是指针，p2是int
因此为了不引起误导，通常可以写成int *p1,p2;

常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是否是一个常量不做限定。因此所引用的对象如果是非常量，依然可以通过其他途径进行改变。

指针和const
指向常量的指针：
const double pi = 3.14
const double *cptr = &pi;
指向常量的指针和常量引用不过是一厢情愿罢了，只是不能通过他们去改变变量的值，但变量依然可以通过其他途径来进行改变。
常量指针：
int errNum = 0;
int *const curErr = &errNum;
常量指针不可以指向其他变量，但依然可以改变目前所指向的对象。

5. using typedef
类型别名关键字

6. auto decltype
auto用于类型推断，一般会忽略掉顶层const
decltype可以通过计算表达式推断类型，他不会忽略顶层const,并且如果给计算表达式加上括号的话，结果是将是引用类型。

7. mutable
在类定义中使用mutable，即使const类对象或者const成员函数，也可以修改mutable修饰的变量。

8. explicit
explicit关键字可以抑制构造函数的隐式转换。构造函数能够隐式转换的条件为只有一个实参，且只允许一步转换。

9. ref