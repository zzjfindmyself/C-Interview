c++11中有很多的新特性，比如智能指针，cast转化,以及move,右值引用等等，这些都令我这个习惯了使用简单特性的学习者感到有些不适应，但是这些应用在学习和工作中又是十分有用的，因此总结一下是很有必要。

1. 智能指针
c++11中有三个智能指针，分别是shared_ptr,weak_ptr,unique_ptr,这三种智能指针共同协作，对内部指针的生命周期进行管理，在不同应用场景中达到了RAII的作用，
    - shared_ptr
    共享指针，这种类型的智能指针可以共享一个内部指针，该内部指针会在最后一个指向他的智能指针被销毁时释放，它使用的是计数机制，可以通过use_count()来查看资源所有者的个数.以下是一些使用法则
    1. 可以使用new和make_shared<>进行构造，也可以通过传递其他智能指针进行构造。
    2. 尽管可以通过*p来进行解引用，但是最好不要这样操作，容易引起内存泄漏。
    3. unique函数可以确定是否独占资源
    4. swap可以交换两个shared_ptr对象
    - weak_ptr
    weak_ptr与shared_ptr不同的是，它不控制对象生命周期，它指向一个shared_ptr管理的对象，weak_ptr只有对象的访问权，但没有控制权，他的构造与析构不会引起引用计数的变化，并且可以解决循环引用的问题。
    - unique_ptr
    unique_ptr 不共享它的指针。它无法复制到其他 unique_ptr，无法通过值传递到函数，也无法用于需要副本的任何标准模板库 (STL) 算法。只能移动unique_ptr。这意味着，内存资源所有权将转移到另一 unique_ptr，并且原始 unique_ptr 不再拥有此资源。我们建议你将对象限制为由一个所有者所有，因为多个所有权会使程序逻辑变得复杂。因此，当需要智能指针用于纯 C++ 对象时，可使用 unique_ptr，而当构造 unique_ptr 时，可使用make_unique Helper 函数。

2. cast转换
原有的类型转换分为隐式转换和显示（强制）转换，但由于强制转换不够明确，没有错误检查，容易出错，因此c++11添加了四种cast转换。
    - const_cast:用于将const变量转为非const
    - static_cast:用于各种隐式转换，比如非const转成const,void*转指针，可以用于多态向上转化，如果向下转可以成功但不安全。
    - dynamic_cast:动态类型转换，只能应用于含有虚函数的类，用于类层次间的向上或向下转换，只能用于转换指针或者引用。向下转换如果是非法的，那么指针返回NULL，引用抛出异常。
    - reinterpret_cast:几乎什么都可以转，尽量少用


3. 右值引用

4. lambda表达式

5. constexpr
